#+TITLE:    computation.environment README
#+AUTHOR:   Jan Moringen
#+EMAIL:    jmoringe@techfak.uni-bielefeld.de
#+LANGUAGE: en

#+SEQ_TODO: TODO STARTED | DONE
#+OPTIONS: num:nil

* STARTED Introduction

  The ~compoutation.environment~ library provides protocols and
  implementations for environments (not necessarily Common Lisp
  environments or Lisp environments), that is data structures which
  manage bindings of names to values. Different kinds of environments
  are available:

  + Global environments
  + Lexical environments

  Lexical environments can be organized in a hierarchy such that child
  environments inherit entries from their ancestors.

  Another feature are first-class namespaces: environments contain
  namespaces which in turn control how names are organized and
  processed within the environment.

* STARTED Concepts

  This section introduces the terminology used in the remainder of
  this document.

  + <<glossary:name>> Name :: In this context, a name is an object the
       purpose of which is referring to another object. Their are
       different kinds of names with different associated rules
       regarding which objects are legal name of that kind and the
       comparison of names. All names of one particular kind form a
       [[glossary:namespace][namespace]].

  + <<glossary:namespace>> Namespace :: A namespace defines a
       particular kind of [[glossary:name][name]] for which it controls

    + <<glossary:name-syntax>> Name syntax :: Which objects are valid
         names in the namespace?

         For example, legal variable names are typically symbols
         (excluding constants such as ~cl:nil~, ~cl:t~ and
         ~cl:pi~). Function names, on the other hand, can also be of
         the form ~(cl:setf NAME)~.

    + <<glossary:name-comparison>> Name comparison :: Given two
         objects which are valid names, how to decide whether they
         designate the same name?

         For example, ~name1~ and ~name2~ must be ~eq~ in order to
         designate the same [[glossary:name][variable name]]. However, ~name1~ and
         ~name2~ in ~(let ((name1 (list 'setf foo)) (name2 (list 'setf
         foo))))~ are not ~eq~ yet still designate the same /function
         name/.

    + Entry isolation :: Not sure

    For example, legal variable names are typically symbols (excluding
    constants such as ~cl:nil~, ~cl:t~ and ~cl:pi~) and can be
    compared using ~cl:eq~. Function names, on the other hand, can
    also be of the form ~(cl:setf NAME)~ and must be compared using
    ~cl:equal~ or a specialized function. In a non-Lisp use-case,
    names could be non-empty strings and ~string=~ or
    ~string-equal~ could be appropriate comparison functions.

  + <<glossary:environment>> Environment :: At the minimum, a
       collection of [[glossary:namespace][namespaces]] and associated [[glossary:binding][binding]] collections. An
       environment may have other parts such as a reference to a
       parent environment.

  + <<glossary:binding>> Binding :: An association of a [[glossary:name][name]] in a
       [[glossary:namespace][namespace]] and a value.

  + <<glossary:scope>> Scope :: A scopes controls the way in which a
       value is looked up for a given name, [[glossary:namespace][namespace]] and [[glossary:environment][environment]].

       As a concrete example, the /direct/ scope constrains the lookup
       to the specified environment, that is ancestors of the
       environment are not considered.

* STARTED Tutorial

  #+BEGIN_SRC lisp :exports results :results silent
    (ql:quickload :computation.environment)
  #+END_SRC

** STARTED Making environments

   This library provides different kinds of environments such as
   ~global-environment~.

   #+BEGIN_SRC lisp :exports both :results output
     (defvar *environment* (make-instance 'computation.environment:global-environment))

     (setf (computation.environment:lookup 'function 'computation.environment:namespace *environment*)
           (make-instance 'computation.environment::eq-namespace))

     (describe *environment*)
   #+END_SRC

   #+RESULTS:
   : #<GLOBAL-ENVIRONMENT 1 namespace {100A817B03}>
   :
   :   EQ-NAMESPACE COMMON-LISP:FUNCTION 0 entries
   :

** STARTED Looking up bindings

   #+BEGIN_SRC lisp :exports both
     (handler-case
         (computation.environment:lookup 'foo 'function *environment*)
       (error (condition)
         (princ-to-string condition)))
   #+END_SRC

   #+RESULTS:
   : An entry for name FOO does not exist in namespace #<EQ-NAMESPACE {100BDBF7B3}>
   : in environment #<GLOBAL-ENVIRONMENT 1 namespace {100A817B03}>

   #+BEGIN_SRC lisp :exports both
     (computation.environment:entries 'function *environment*)
   #+END_SRC

   #+RESULTS:
   : NIL

** STARTED Adding bindings

   New bindings can be created in two ways

   1. Destructively modifying a given environment by adding the new
      binding to it

   2. Creating a new environment object that contains the new binding
      and is linked to the existing environment object

   The first way can be achieved using the ~(setf
   computation.environment:lookup)~ generic function:

   #+BEGIN_SRC lisp :exports both
     (setf (computation.environment:lookup 'foo 'function *environment*) :foo)
     (computation.environment:lookup 'foo 'function *environment*)
   #+END_SRC

   #+RESULTS:
   : :FOO

   The functions ~computation.environment:augmented-environment~ and
   ~computation.environment:augmented-namespace~ implement the second
   way:

   #+BEGIN_SRC lisp :exports both :results output
     (let ((augmented (computation.environment:augmented-namespace
                       *environment* 'function '(bar) '(:bar)
                       :class 'computation.environment::lexical-environment)))
       (describe augmented)
       (handler-case
           (computation.environment:lookup 'bar 'function augmented)
         (error (condition)
           (princ-to-string condition))))
   #+END_SRC

   #+RESULTS:
   : #<LEXICAL-ENVIRONMENT 1 namespace @1 {1011E28F13}>
   :
   :   EQ-NAMESPACE COMMON-LISP:FUNCTION 2 entries
   :     BAR → :BAR
   :     FOO → :FOO [inherited from #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>]

   but the original environment is not affected:

   #+BEGIN_SRC lisp :exports both :results output
     (describe *environment*)
   #+END_SRC

   #+RESULTS:
   : #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>
   :
   :   EQ-NAMESPACE COMMON-LISP:FUNCTION 1 entry
   :     FOO → :FOO

** TODO Shadowing

   #+BEGIN_SRC lisp :exports both :results output
     (let ((augmented (computation.environment:augmented-namespace
                       *environment* 'function '(foo) '(:bar)
                       :class 'computation.environment::lexical-environment)))
       (describe *environment*)
       (terpri) (terpri)
       (describe augmented) (clouseau:inspect augmented :new-process t))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>

     EQ-NAMESPACE COMMON-LISP:FUNCTION 1 entry
       FOO → :FOO

   #<LEXICAL-ENVIRONMENT 1 namespace @1 {1005097E73}>

     EQ-NAMESPACE COMMON-LISP:FUNCTION 2 entries
       FOO → :BAR
       FOO → :FOO [inherited from #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>]
   #+end_example

* STARTED Dictionary

  #+BEGIN_SRC lisp :results none :exports none :session "doc"
    #.(progn
        #1=(ql:quickload '(:computation.environment :alexandria :split-sequence))
        '#1#)
    (defun doc (symbol kind)
      (let* ((lambda-list (sb-introspect:function-lambda-list symbol))
             (string      (documentation symbol kind))
             (lines       (split-sequence:split-sequence #\Newline string))
             (trimmed     (mapcar (alexandria:curry #'string-left-trim '(#\Space)) lines)))
        (format nil "~(~A~) ~<~{~A~^ ~}~:@>~2%~{~A~^~%~}"
                symbol (list lambda-list) trimmed)))
  #+END_SRC

** STARTED The bindings protocol

   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:make-bindings 'function)
   #+END_SRC

   #+RESULTS:
   : make-bindings NAMESPACE ENVIRONMENT
   :
   : Return a bindings object for NAMESPACE in ENVIRONMENT.
   :
   : The returned object must be usable with NAMESPACE and ENVIRONMENT
   : in the bindings protocol.

   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:entry-count-in-bindings 'function)
   #+END_SRC

   #+RESULTS:
   : entry-count-in-bindings BINDINGS NAMESPACE ENVIRONMENT
   :
   : Return the number of entries in BINDINGS in NAMESPACE, ENVIRONMENT.

** TODO The environment protocol

** TODO The hierarchical environment protocol
