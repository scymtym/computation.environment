#+TITLE:    computation.environment README
#+AUTHOR:   Jan Moringen
#+EMAIL:    jmoringe@techfak.uni-bielefeld.de
#+LANGUAGE: en

#+SEQ_TODO: TODO STARTED | DONE
#+OPTIONS: num:nil

* STARTED Introduction

  The ~compoutation.environment~ library provides protocols and
  implementations for environments (not necessarily Common Lisp
  environments or Lisp environments), that is data structures which
  manage bindings of names to values. Different kinds of environments
  are available:

  + Global environments
  + Lexical environments

  Lexical environments can be organized in a hierarchy such that child
  environments inherit entries from their ancestors.

  Another feature are first-class namespaces: environments contain
  namespaces which in turn control how names are organized and
  processed within the environment.

* STARTED Concepts

  This section introduces the terminology used in the remainder of
  this document.

  + <<glossary:name>> Name :: In this context, a name is an object the
       purpose of which is referring to another object. Their are
       different kinds of names with different associated rules
       regarding which objects are legal name of that kind and the
       comparison of names. All names of one particular kind form a
       [[glossary:namespace][namespace]].

  + <<glossary:namespace>> Namespace :: A namespace defines a
       particular kind of [[glossary:name][name]] for which it controls

    + <<glossary:name-syntax>> Name syntax :: Which objects are valid
         names in the namespace?

         For example, legal variable names are typically symbols
         (excluding constants such as ~cl:nil~, ~cl:t~ and
         ~cl:pi~). Function names, on the other hand, can also be of
         the form ~(cl:setf NAME)~.

    + <<glossary:name-comparison>> Name comparison :: Given two
         objects which are valid names, how to decide whether they
         designate the same name?

         For example, ~name1~ and ~name2~ must be ~eq~ in order to
         designate the same [[glossary:name][variable name]]. However, ~name1~ and
         ~name2~ in ~(let ((name1 (list 'setf foo)) (name2 (list 'setf
         foo))))~ are not ~eq~ yet still designate the same /function
         name/.

    + Entry isolation :: Not sure

    For example, legal variable names are typically symbols (excluding
    constants such as ~cl:nil~, ~cl:t~ and ~cl:pi~) and can be
    compared using ~cl:eq~. Function names, on the other hand, can
    also be of the form ~(cl:setf NAME)~ and must be compared using
    ~cl:equal~ or a specialized function. In a non-Lisp use-case,
    names could be non-empty strings and ~string=~ or
    ~string-equal~ could be appropriate comparison functions.

  + <<glossary:environment>> Environment :: At the minimum, a
       collection of [[glossary:namespace][namespaces]] and associated [[glossary:binding][binding]] collections. An
       environment may have other parts such as a reference to a
       parent environment.

  + <<glossary:binding>> Binding :: An association of a [[glossary:name][name]] in a
       [[glossary:namespace][namespace]] and a value.

  + <<glossary:scope>> Scope :: A scopes controls the way in which a
       value is looked up for a given name, [[glossary:namespace][namespace]] and [[glossary:environment][environment]].

       As a concrete example, the /direct/ scope constrains the lookup
       to the specified environment, that is ancestors of the
       environment are not considered.

* STARTED Tutorial

  #+BEGIN_SRC lisp :exports results :results silent
    (ql:quickload :computation.environment)
  #+END_SRC

** STARTED Making environments

   This library provides different kinds of environments such as
   ~global-environment~.

   #+BEGIN_SRC lisp :exports both :results output
     (defvar *environment* (make-instance 'computation.environment:global-environment))

     (setf (computation.environment:lookup 'function 'computation.environment:namespace *environment*)
           (make-instance 'computation.environment::eq-namespace))

     (describe *environment*)
   #+END_SRC

   #+RESULTS:
   : #<GLOBAL-ENVIRONMENT 1 namespace {100A817B03}>
   :
   :   EQ-NAMESPACE COMMON-LISP:FUNCTION 0 entries
   :

** STARTED Looking up bindings

   #+BEGIN_SRC lisp :exports both
     (handler-case
         (computation.environment:lookup 'foo 'function *environment*)
       (error (condition)
         (princ-to-string condition)))
   #+END_SRC

   #+RESULTS:
   : An entry for name FOO does not exist in namespace #<EQ-NAMESPACE {100BDBF7B3}>
   : in environment #<GLOBAL-ENVIRONMENT 1 namespace {100A817B03}>

   #+BEGIN_SRC lisp :exports both
     (computation.environment:entries 'function *environment*)
   #+END_SRC

   #+RESULTS:
   : NIL

** STARTED Adding bindings

   New bindings can be created in two ways

   1. Destructively modifying a given environment by adding the new
      binding to it

   2. Creating a new environment object that contains the new binding
      and is linked to the existing environment object

   The first way can be achieved using the ~(setf
   computation.environment:lookup)~ generic function:

   #+BEGIN_SRC lisp :exports both
     (setf (computation.environment:lookup 'foo 'function *environment*) :foo)
     (computation.environment:lookup 'foo 'function *environment*)
   #+END_SRC

   #+RESULTS:
   : :FOO

   The functions ~computation.environment:augmented-environment~ and
   ~computation.environment:augmented-namespace~ implement the second
   way:

   #+BEGIN_SRC lisp :exports both :results output
     (let ((augmented (computation.environment:augmented-namespace
                       *environment* 'function '(bar) '(:bar)
                       :class 'computation.environment::lexical-environment)))
       (describe augmented)
       (handler-case
           (computation.environment:lookup 'bar 'function augmented)
         (error (condition)
           (princ-to-string condition))))
   #+END_SRC

   #+RESULTS:
   : #<LEXICAL-ENVIRONMENT 1 namespace @1 {1011E28F13}>
   :
   :   EQ-NAMESPACE COMMON-LISP:FUNCTION 2 entries
   :     BAR → :BAR
   :     FOO → :FOO [inherited from #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>]

   but the original environment is not affected:

   #+BEGIN_SRC lisp :exports both :results output
     (describe *environment*)
   #+END_SRC

   #+RESULTS:
   : #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>
   :
   :   EQ-NAMESPACE COMMON-LISP:FUNCTION 1 entry
   :     FOO → :FOO

** STARTED Shadowing

   #+BEGIN_SRC lisp :exports both :results output
     (let ((augmented (computation.environment:augmented-namespace
                       *environment* 'function '(foo) '(:bar)
                       :class 'computation.environment::lexical-environment)))
       (describe *environment*)
       (terpri) (terpri)
       (describe augmented))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>

     EQ-NAMESPACE COMMON-LISP:FUNCTION 1 entry
       FOO → :FOO

   #<LEXICAL-ENVIRONMENT 1 namespace @1 {1005097E73}>

     EQ-NAMESPACE COMMON-LISP:FUNCTION 2 entries
       FOO → :BAR
       FOO → :FOO [inherited from #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>]
   #+end_example

* STARTED Dictionary

  #+BEGIN_SRC lisp :results none :exports none :session "doc"
    #.(progn
        #1=(ql:quickload '(:computation.environment :alexandria :split-sequence))
        '#1#)
    ,#+no (defun doc (symbol kind)
      (let* ((lambda-list (sb-introspect:function-lambda-list symbol))
             (string      (documentation symbol kind))
             (lines       (split-sequence:split-sequence #\Newline string))
             (trimmed     (mapcar (alexandria:curry #'string-left-trim '(#\Space)) lines)))
        (format t "~~~(~A~)~~ src_lisp[:exports code]{~<~{~A~^ ~}~:@>}~2%~{~A~^~%~}"
                symbol (list lambda-list) trimmed)))
    (in-package #:cl-user)

    (defun doc (symbol kind)
      (let* ((lambda-list (sb-introspect:function-lambda-list symbol))
             (string      (documentation symbol kind))
             (trimmed     (text.documentation-string.parser::remove-common-leading-whitespace string)))
        (format t "~(~A~) ~<~{~A~^ ~}~:@>~2%"
                symbol (list lambda-list))
        (text.documentation-string.parser::render-org 'list (text.documentation-string.parser::parse trimmed) *standard-output*)))
  #+END_SRC

** STARTED The bindings protocol

   This low-level protocol is responsible for creating and accessing
   [[glossary:binding][bindings]] in a given [[glossary:namespace][namespace]]. Clients should usually use the
   higher-level [[#sec:dictionary-environment-protocol][environment protocol]].

   <<generic-function:make-bindings>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:make-bindings 'function)
   #+END_SRC

   #+RESULTS:
   : make-bindings NAMESPACE ENVIRONMENT
   :
   : Return a bindings object for NAMESPACE in ENVIRONMENT.
   :
   : The returned object must be usable with NAMESPACE and ENVIRONMENT
   : in the bindings protocol.

   <<generic-function:entry-count-in-bindings>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:entry-count-in-bindings 'function)
   #+END_SRC

   #+RESULTS:
   : entry-count-in-bindings BINDINGS NAMESPACE ENVIRONMENT
   :
   : Return the number of entries in BINDINGS in NAMESPACE, ENVIRONMENT.

   <<generic-function:map-entries-in-bindings>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:map-entries-in-bindings 'function)
   #+END_SRC

   #+RESULTS:
   : map-entries-in-bindings FUNCTION BINDINGS NAMESPACE ENVIRONMENT
   :
   : NIL

   <<generic-function:lookup-in-bindings>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:lookup-in-bindings 'function)
   #+END_SRC

   #+RESULTS:
   : lookup-in-bindings NAME BINDINGS NAMESPACE ENVIRONMENT
   :
   : NIL

   <<generic-function:setf-lookup-in-bindings>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc '(setf computation.environment:lookup-in-bindings) 'function)
   #+END_SRC

   #+RESULTS:
   : (setf lookup-in-bindings) NEW-VALUE NAME BINDINGS NAMESPACE ENVIRONMENT
   :
   : NIL


** STARTED The environment protocol
   :PROPERTIES:
   :CUSTOM_ID: sec:dictionary-environment-protocol
   :END:

   <<generic-function:entry-count>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:entry-count 'function)
   #+END_SRC

   #+RESULTS:
   : entry-count NAMESPACE ENVIRONMENT &KEY SCOPE
   :
   : Return the number of entries in NAMESPACE in ENVIRONMENT for SCOPE.

   <<generic-function:map-entries>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:map-entries 'function)
   #+END_SRC

   #+RESULTS:
   : map-entries FUNCTION NAMESPACE ENVIRONMENT &KEY SCOPE
   :
   : Call FUNCTION for each entry in NAMESPACE in ENVIRONMENT for SCOPE.
   :
   : The lambda list of FUNCTION must be compatible with
   :
   : (name value container)

   <<generic-function:entries>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:entries 'function)
   #+END_SRC

   #+RESULTS:
   : entries NAMESPACE ENVIRONMENT &KEY SCOPE
   :
   : Return entries in NAMESPACE in ENVIRONMENT for SCOPE as an alist.

   <<generic-function:lookup>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:lookup 'function)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   lookup NAME NAMESPACE ENVIRONMENT &KEY IF-DOES-NOT-EXIST SCOPE

   Lookup and return the value for NAME in NAMESPACE in ENVIRONMENT for SCOPE.

   Return three values: 1) the found value (subject to
   IF-DOES-NOT-EXIST) 2) a Boolean indicating whether a value exists
   3) the environment in which the value was found.

   SCOPE controls which bindings are considered. Examples of scopes
   include binding directly contained in ENVIRONMENT and bindings
   contained in ENVIRONMENT or any of its ancestor environments.

   IF-DOES-NOT-EXIST controls the behavior in case such a value does
   not exist.
   #+end_example

   <<generic-function:setf-lookup>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc '(setf computation.environment:lookup) 'function)
   #+END_SRC

   #+RESULTS:
   : (setf lookup) NEW-VALUE NAME NAMESPACE ENVIRONMENT &KEY IF-DOES-NOT-EXIST
   :
   : Set the value of NAME in NAMESPACE in ENVIRONMENT to NEW-VALUE.

   <<generic-function:make-or-update>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:make-or-update 'function)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   make-or-update NAME NAMESPACE ENVIRONMENT MAKE-CONT UPDATE-CONT &KEY SCOPE

   Use MAKE-CONT or UPDATE-CONT to set NAME in NAMESPACE in ENVIRONMENT for SCOPE.

   Return four values: 1) the new value of NAME in NAMESPACE in
   ENVIRONMENT 2) a Boolean indicating whether the value of NAME in
   NAMESPACE in ENVIRONMENT has been updated 3) the previous value of
   NAME in NAMESPACE in ENVIRONMENT 4) the container in which the
   previous value was found.

   If no value exists for NAME in NAMESPACE in ENVIRONMENT, MAKE-CONT
   is called to make a value which is then set as the value of NAME
   in NAMESPACE in ENVIRONMENT.

   If a value exists for NAME in NAMESPACE in environment,
   UPDATE-CONT is called with the existing value and its container to
   potentially compute an updated value. If an updated value is
   computed, that value is set as the value of NAME in NAMESPACE in
   ENVIRONMENT.

   MAKE-CONT has to be a function with a lambda list compatible to

   ()

   and has to return the new value as its primary return value.

   UPDATE-CONT has to be a function with a lambda list compatible to

   (old-value old-container)

   and must return between two values and three values when called:
   1) an updated value based on OLD-VALUE 2) a Boolean indicating
   whether the first return value is different from OLD-VALUE 3)
   optionally a container in which the returned updated value should
   be set.
   #+end_example

   <<generic-function:ensure>>
   #+BEGIN_SRC lisp :results output raw :exports results :session "doc"
     (in-package #:cl-user)
     (doc 'computation.environment:ensure 'function)
   #+END_SRC

   #+RESULTS:

** STARTED The hierarchical environment protocol

   <<generic-function:parent>>
   #+BEGIN_SRC lisp :results output raw :exports results :session "doc"
     (in-package #:cl-user)
     (doc 'computation.environment:parent 'function)
   #+END_SRC

   #+RESULTS:

   <<generic-function:root>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:root 'function)
   #+END_SRC

   #+RESULTS:
   : root ENVIRONMENT
   :
   : Return the ancestor of ENVIRONMENT that has no parent.
   :
   : In particular, if ENVIRONMENT does not have a parent, return
   : ENVIRONMENT.

   <<generic-function:depth>>
   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:depth 'function)
   #+END_SRC

   #+RESULTS:
   : depth ENVIRONMENT
   :
   : Return the number of ancestors ENVIRONMENT has.
   :
   : In particular, return 0 if ENVIRONMENT does not have a parent.
