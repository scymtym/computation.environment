#+SEQ_TODO: TODO STARTED | DONE
#+OPTIONS: num:nil

* TODO Introduction

* TODO Tutorial

  #+BEGIN_SRC lisp :exports results :results silent
    (ql:quickload :computation.environment)
  #+END_SRC

** TODO Making environments

   #+BEGIN_SRC lisp :exports both
     (defvar *environment* (make-instance 'computation.environment:global-environment))
     (setf (computation.environment:lookup 'function 'computation.environment::namespace *environment*)
           (make-instance 'computation.environment::eq-namespace))
     *environment*
   #+END_SRC

   #+RESULTS:
   : #<GLOBAL-ENVIRONMENT 1 namespace {1007E13A63}>

** TODO Looking up bindings

   #+BEGIN_SRC lisp :exports both
     (handler-case
         (computation.environment:lookup 'foo 'function *environment*)
       (error (condition)
         (princ-to-string condition)))
   #+END_SRC

   #+RESULTS:
   : An entry for name FOO does not exist in namespace FUNCTION in environment
   : #<GLOBAL-ENVIRONMENT 1 namespace {1009D8D703}>

   #+BEGIN_SRC lisp :exports both
     (computation.environment:entries 'function *environment*)
   #+END_SRC

   #+RESULTS:
   : NIL

** TODO Adding bindings

   #+BEGIN_SRC lisp :exports both
     (setf (computation.environment:lookup 'foo 'function *environment*) :foo)
     (handler-case
         (computation.environment:lookup 'foo 'function *environment*)
       (error (condition)
         (princ-to-string condition)))
   #+END_SRC

   #+RESULTS:
   : :FOO

   #+BEGIN_SRC lisp :exports both
     (let ((augmented (computation.environment:augmented-namespace
                       ,*environment* 'function '(bar) '(:bar)
                       :class 'computation.environment::lexical-environment)))
       (handler-case
           (computation.environment:lookup 'bar 'function augmented)
         (error (condition)
           (princ-to-string condition))))
   #+END_SRC

   #+RESULTS:
   : :BAR


* TODO Dictionary
