#+SEQ_TODO: TODO STARTED | DONE
#+OPTIONS: num:nil

* STARTED Introduction

  The ~compoutation.environment~ library provides protocols and
  implementations for environments, that is data structures which
  manage bindings of names to values. Different kinds of environments
  are available:

  + Global environments
  + Lexical environments

  Lexical environments can be organized in a hierarchy such that child
  environments inherit entries from their ancestors.

  Another feature are first-class namespaces: environments contain
  namespaces which in turn control how names are organized and
  processed within the environment.

* STARTED Concepts

  + Name :: Different kinds of names, different equalities

  + Namespace :: A namespace defines a particular kind of /name/ for
                 which it controls

    + Name syntax :: Which objects are valid names in the namespace?

    + Name comparison :: Given two objects which are valid names, how
         to decide whether they designate the same name?

         For example, ~name1~ and ~name2~ must be ~eq~ in order to
         designate the same /variable name/. However, ~name1~ and
         ~name2~ in ~(let ((name1 (list 'setf foo)) (name2 (list 'setf
         foo))))~ are not ~eq~ yet still designate the same /function
         name/.

    + Entry isolation :: Not sure

  + Environment ::

  + Binding :: An association of a /name/ in a /namespace/ and a
               value.

  + scope :: A scopes controls the way in which a value is looked up
             for a given name, /namespace/ and /environment/.

             As a concrete example, the /direct/ scope constrains the
             lookup to the specified environment, that is ancestors of
             the environment are not considered.

* STARTED Tutorial

  #+BEGIN_SRC lisp :exports results :results silent
    (ql:quickload :computation.environment)
  #+END_SRC

** STARTED Making environments

   This library provides different kinds of environments such as
   ~global-environment~.

   #+BEGIN_SRC lisp :exports both :results output
     (defvar *environment* (make-instance 'computation.environment:global-environment))

     (setf (computation.environment:lookup 'function 'computation.environment:namespace *environment*)
           (make-instance 'computation.environment::eq-namespace))

     (describe *environment*)
   #+END_SRC

   #+RESULTS:
   : #<GLOBAL-ENVIRONMENT 1 namespace {100A817B03}>
   :
   :   EQ-NAMESPACE COMMON-LISP:FUNCTION 0 entries
   :

** STARTED Looking up bindings

   #+BEGIN_SRC lisp :exports both
     (handler-case
         (computation.environment:lookup 'foo 'function *environment*)
       (error (condition)
         (princ-to-string condition)))
   #+END_SRC

   #+RESULTS:
   : An entry for name FOO does not exist in namespace #<EQ-NAMESPACE {100BDBF7B3}>
   : in environment #<GLOBAL-ENVIRONMENT 1 namespace {100A817B03}>

   #+BEGIN_SRC lisp :exports both
     (computation.environment:entries 'function *environment*)
   #+END_SRC

   #+RESULTS:
   : NIL

** STARTED Adding bindings

   New bindings can be created in two ways

   1. Destructively modifying a given environment by adding the new
      binding to it

   2. Creating a new environment object that contains the new binding
      and is linked to the existing environment object

   The first way can be achieved using the ~(setf
   computation.environment:lookup)~ generic function:

   #+BEGIN_SRC lisp :exports both
     (setf (computation.environment:lookup 'foo 'function *environment*) :foo)
     (computation.environment:lookup 'foo 'function *environment*)
   #+END_SRC

   #+RESULTS:
   : :FOO

   The functions ~computation.environment:augmented-environment~ and
   ~computation.environment:augmented-namespace~ implement the second
   way:

   #+BEGIN_SRC lisp :exports both :results output
     (let ((augmented (computation.environment:augmented-namespace
                       *environment* 'function '(bar) '(:bar)
                       :class 'computation.environment::lexical-environment)))
       (describe augmented)
       (handler-case
           (computation.environment:lookup 'bar 'function augmented)
         (error (condition)
           (princ-to-string condition))))
   #+END_SRC

   #+RESULTS:
   : #<LEXICAL-ENVIRONMENT 1 namespace @1 {1011E28F13}>
   :
   :   EQ-NAMESPACE COMMON-LISP:FUNCTION 2 entries
   :     BAR → :BAR
   :     FOO → :FOO [inherited from #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>]

   but the original environment is not affected:

   #+BEGIN_SRC lisp :exports both :results output
     (describe *environment*)
   #+END_SRC

   #+RESULTS:
   : #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>
   :
   :   EQ-NAMESPACE COMMON-LISP:FUNCTION 1 entry
   :     FOO → :FOO

** TODO Shadowing

   #+BEGIN_SRC lisp :exports both :results output
     (let ((augmented (computation.environment:augmented-namespace
                       *environment* 'function '(foo) '(:bar)
                       :class 'computation.environment::lexical-environment)))
       (describe *environment*)
       (terpri) (terpri)
       (describe augmented) (clouseau:inspect augmented :new-process t))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>

     EQ-NAMESPACE COMMON-LISP:FUNCTION 1 entry
       FOO → :FOO

   #<LEXICAL-ENVIRONMENT 1 namespace @1 {1005097E73}>

     EQ-NAMESPACE COMMON-LISP:FUNCTION 2 entries
       FOO → :BAR
       FOO → :FOO [inherited from #<GLOBAL-ENVIRONMENT 2 namespaces {10028B3063}>]
   #+end_example

* STARTED Dictionary

  #+BEGIN_SRC lisp :results none :exports none :session "doc"
    #.(progn
        #1=(ql:quickload '(:computation.environment :alexandria :split-sequence))
        '#1#)
    (defun doc (symbol kind)
      (let* ((lambda-list (sb-introspect:function-lambda-list symbol))
             (string      (documentation symbol kind))
             (lines       (split-sequence:split-sequence #\Newline string))
             (trimmed     (mapcar (alexandria:curry #'string-left-trim '(#\Space)) lines)))
        (format nil "~(~A~) ~<~{~A~^ ~}~:@>~2%~{~A~^~%~}"
                symbol (list lambda-list) trimmed)))
  #+END_SRC

** STARTED The bindings protocol

   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:make-bindings 'function)
   #+END_SRC

   #+RESULTS:
   : make-bindings NAMESPACE ENVIRONMENT
   :
   : Return a bindings object for NAMESPACE in ENVIRONMENT.
   :
   : The returned object must be usable with NAMESPACE and ENVIRONMENT
   : in the bindings protocol.

   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 'computation.environment:entry-count-in-bindings 'function)
   #+END_SRC

   #+RESULTS:
   : entry-count-in-bindings BINDINGS NAMESPACE ENVIRONMENT
   :
   : Return the number of entries in BINDINGS in NAMESPACE, ENVIRONMENT.

** TODO The environment protocol

** TODO The hierarchical environment protocol
